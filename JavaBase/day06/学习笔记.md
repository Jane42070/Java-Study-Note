# 接口

## 用集合优化黑马信息管理系统

- 优化步骤：
    - 开放封闭原则
    - 创建新的 StudentDao 类，OtherStudentDao
    - 创建 ArrayList 集合容器对象
    - OtherStudentDao 中的方法声明，需要跟 StudentDao 保持一致
        - 注意：如果不一致，StudentService 中的代码就需要进行修改
    - 完善方法（添加、删除、修改、查看）
    - 替换 StudentService 中的 Dao 对象

## 接口介绍

- 规则的定义
- 程序的拓展性

## 接口的定义和特点

- 接口用关键字interface来定义
    - public interface 接口名{}
- 接口不能实例化
- 接口和类之间是实现关系，通过 implements 关键字表示
    - public class 类名 implements 接口名{}
- 接口的子类（实现类）
    - 要么重写接口中的所有抽象方法
    - 要么是抽象类
- 注意：接口和类的实现关系，可以单实现，也可以多实现
    - public class 类名 implements 接口名1, 接口名2{}

## 接口中成员的特点

- 成员变量
    - 只能是常量
    - 默认修饰符：public static final
- 构造方法
    - 没有
- 成员方法
    - 只能是抽象方法
    - 默认修饰符：public abstract

### JDK8 版本中接口成员的特点

- JDK8版本后，Java只对接口的成员方法进行了改进
    - 允许接口中定义非抽象方法（带有方法体的方法），但是需要关键字default修饰，这些方法是默认方法
    - 作用：解决接口升级的问题
- 接口中默认方法的定义格式：
    - 格式：public default 返回值类型 方法名(参数列表){}
- 接口中默认方法的注意事项：
    - 默认方法不是抽象方法，所以不强制被重写，但是可以被重写，重写的时候去掉 default 关键字
    - public 可以省略，default 不能省略
    - 如果实现了多个接口，多个接口中存在相同的方法声明，子类必须对该方法进行重写
- 接口中允许定义static静态方法
    - 定义格式：
        - 格式：public static 返回值类型 方法名(参数列表){}
        - 范例：public static void show(){}
- 接口中静态方法的注意事项
    - 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用
    - public 可以省略，static 不能省略

### JDK9 版本中接口成员的特点

- 格式1：private 返回值类型 方法名(参数列表){}
- 范例1：private void show()
- 格式2：private static 返回值类型 方法名(参数列表){}
- 范例2：private static void method(){}

## 接口的使用思路

- 如果发现一个类中所有的方法都是抽象方法，那么就可以将该类，改进为一个接口
- 涉及到了借口大面积更新方法，而不想去修改每一个实现类，就可以将更新的方法，定义为带有方法体的默认方法
- 希望默认方法调用的更加简介，可以考虑设计为static静态方法（需要去掉 default 关键字）
- 默认方法中出现了重复的代码，可以考虑抽取出一个私有方法（需要去掉 default 关键字）

## 类和接口的关系

- 类和类的关系
    - 继承关系，只能单继承，但是可以多层继承
- 类和接口的关系
    - 实现关系，可以单实现，也可以多实现，还可以继承一个类的同时实现多个接口
- 接口和接口的关系
    - 继承关系，可以单继承，也可以多继承

# 黑马信息管理系统改进

- 实现步骤
    - 将BaseStudentDao改进为一个接口
    - 让StudentDao和OtherStudentDao实现这个接口
- 实现步骤
    - 创建factory包，创建StudentDaoFactory（工厂类）
    - 提供 static 修改的 getStudentDao 方法，该方法用于创建 StudentDao 对象并返回

# 多态

## 多态概述

- 同一个对象，在不同时刻表现出来的不同形态
- 举例：猫
    - 我们可以说猫是猫：猫 cat = new 猫();
    - 我们也可以说猫是动物：动物 animal = new 猫();
    - 这里猫在不同时刻表现出来了不同的形态，这就是多态
- 多态的前提和体现
    - 有继承/实现关系
    - 有方法重写
    - 有父类引用指向子类对象

## 多态中成员访问特点

- 构造方法：同继承一样，子类会通过super访问父类构造方法
- 成员变量：编译看左边（父类），执行看左边（父类）
- 成员方法：编译看左边（父类），执行看右边（子类）

## 多态的好处和弊端

- 多态的好处：提高了程序的拓展性
    - 具体体现：定义方法的时候，使用父类型作为参数，该方法就可以接受父类的任意子类对象
- 多态的弊端：不能使用子类的特有功能

## 多态中的转型

- 向上转型
    - 从子到父
    - 父类引用指向子类对象
- 向下转型
    - 从父到子
    - 父类引用转为子类对象

## 多态中的转型存在的风险

- 概述：如果被转的引用类型变量，对应的实际类型和目标类型不是同一种类型，那么在转换的时候就会出现
    - 比如 猫类型 转换为 狗类型
    - ClassCastException
    ```java
    class TestPolymorphic {
        public static void main(String[] args) {
          Animal a = new Cat();
        }
        public static void useAnimal(Animal a) {
            Dog d = (Dog) a;
            d.eat();
        }
    }
    ``` 

### 避免强转出现的问题

- 关键字 instanceof
- 使用格式：
    - 变量名 instanceof 类型
    - 通俗的理解：判断关键字左边的变量，是否是右边的类型，返回 boolean 类型结果